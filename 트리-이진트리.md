# 트리

## 트리

### 용어 

- 비선형 구조

- 원소(node)들 간에 1:n 관계를 가지는 자료구조

  - 계층 관계를 가지는 구조(상위 원소에서 하위 원소로 갈수록 확장)

  - root = 최상위 노드, 트리의 시작 노드

  - leaf = 단말 노드 , 최 하단 노드
  - 형제 노드(sibling node) - 같은 부모를 가진 노드
  - 조상 노드 = 간선을 따라 루트까지 이어지는 경로상의 모든 노드
  - 자손 노드 = 서브 트리에 있는 모든 하위 노드

- 간선(edge) = 노드를 연결하는 선

- 서브 트리 : 부모 노드와 간선을 끊었을때 새롭게 생성되는 트리

- 차수(degree)
  - 노드의 차수 : 노드에 연결된 자식 노드의 수 (바로 밑)
  - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값

-  높이
  - 노드의 높이 : 루트에서 노드까지 이르는 간선의 수
  - 트리의 높이 : 트리에 있는 노드 높이 중 가장 큰 값 (최하단까지의 간선의 수)



## 이진 트리

- 모든 노드들이 최대 2개의 서브 트리를 갖는 형태의 트리
  - 각 노드가 자식 노드를 최대 2개까지 가지는 트리

- 높이가 h일 경우 노드의 개수는 (h+1)이상 (2**(h+1)-1)이하

### 이진트리 종류

#### 포화 이진 트리(Full Binary Tree)

- 모든 노드가 포화 상태로 차 있는 이진 트리

- 노드의 개수는 최대인 2**(h+1)-1 개

#### 완전 이진 트리(Complete Binary Tree)

- 노드의 구조가 처음부터 끝까지 포화 이진 트리 구조와 같은 위치에 있지만, 포화 상태까지는 개수가 부족한 구조

#### 편향 이진 트리 (Skewed Binary Tree)

- 한쪽 방향으로만 자식 노드를 가진 이진 트리
- 일직선으로 이어지는 구조



### 이진트리 순회

1. 전위순회(preorder traversal)

   - VLR
   - 부모노드 방문 후 자식 노드를 좌에서 우 순서로 방문
   - 행동->좌측순회->우측순회 구조

   ```python
   def preorder(x):					#child1 = 좌측 자식, child2 = 우측자식
       print(x,end = ' ')				#행동
       if child1[x]:
           preorder(child1[x])			#좌측순회
       if child2[start]:
           preorder(child2[x])			#우측순회
       return
   ```

   

2. 중위순회(inorder traversal)

   - LVR
   - 왼쪽 자식노드, 부모노드, 오른쪽  자식노드 순으로 방문
   - 좌측 순회 -> 행동 -> 우측 순회 구조

   ```python
   def inorder(x):					#child1 = 좌측 자식, child2 = 우측자식
       if child1[x]:
           inorder(child1[x])			#좌측순회
       print(x,end = ' ')				#행동
       if child2[start]:
           inorder(child2[x])			#우측순회
       return

3. 후위순회(postorder traversal)

   - LRV
   - 자식 노드를 좌,우 순서로 방문 후 부모 노드를 방문
   - 좌측순회 -> 우측순회 -> 행동 구조

   ```python
   def postorder(x):					#child1 = 좌측 자식, child2 = 우측자식
       if child1[x]:
           postorder(child1[x])			#좌측순회
       if child2[start]:
           postorder(child2[x])			#우측순회
       print(x,end = ' ')					#행동
       return
   ```

   

### 배열로 이진트리 표현

- 완전 이진 트리 or 포화 이진 트리의 경우 root노드부터 밑의 노드들이 고정된 위치를 가지고 있는 것을 이용
  - 루트를 1번-루트의 왼쪽 자식을 2,오른쪽자식을 3 ...고정된 구조

- 각각의 번호를 list의 index로 사용
  - list[1] = 루트 노드, list[2] = 루트의 왼쪽 자식노드, list[3] = 루트의 오른쪽 자식 노드 ...
  - 부모 노드의 번호 = 자식 노드의 번호 //2
  - 자식 노드의 번호 = 부모노드의 번호 *2 , 부모노드의 번호 *2 +1
  - 레벨 n의 시작 노드 번호는 2**n (레벨 0인 루트는 1번, 그 바로 밑 자식은 레벨1 = > 2번)
- 다른 방법으로는 자식1,2에 해당하는 list 생성
  - index번호  = 부모 번호
  - value = 자식 번호

#### 단점

- 편향 이진트리와 같은 경우엔  list에사용하지 않는 빈 공간 발생으로 인해 메모리 낭비
- 새로운 노드 삽입, 기존 노드 삭제 시 배열의 크기 변경이 어려워 비 효율적



#### 보완

- 연결리스트를 이용하여 트리 표현
  - [왼쪽 자식 노드, 현재 노드, 오른쪽 자식 노드] 구조

### +a 수식 트리

- 수식을 표현하는 이진 트리
- 루트,가지 노드엔 연산자(기호) // 잎 노드엔 피연산자(수)로 된 구조



## 이진 탐색 트리

- 탐색 작업을 효율적으로 하기 위한 구조

- 부모 노드 기준 왼쪽 노드엔 작은값, 오른쪽 노드엔 큰값으로 나눔
- 중위 순회시 오름차순 정렬 가능
- 탐색,삽입,삭제 O(h) // h=트리의 높이 

### 탐색연산

- 루트에서 시작
- 탐색할 값과 루트 값 비교
  - 같을경우 탐색 성공
  - 탐색할 값이 작을 경우 왼쪽 서브트리에서 탐색 시작
  - 탐색할 값이 클 경우 오른쪽 서브트리에서 탐색 시작

### 삽입 연산

- 삽입할 값이 트리 내에 있는지 탐색연산을 통해 확인
- 없을시 실패가 결정되는 장소가 삽입될 위치



## 힙(heap)

- 완전 이진 트리에서 키값이 가장 큰 or 작은 노드를 찾기 위해 만든 구조

### 최대 힙(max heap)

- 부모노드의 키값 > 자식노드의 키값
- 루트 노드 = 키값이 가장 큰 노드

### 최소 힙(min heap)

- 부모노드의 키값 < 자식노드의 키값
- 루트 노드 = 키값이 가장 작은 노드



### 힙 연산에서의 삽입

- 마지막 자리 확장
- 마지막 자리에 할당 후 부모 노드와 비교
  - 값에 따라 부모 노드와 자리 변경

### 힙 연산에서의 삭제

- 루트 노드만 삭제 가능
- 루트노드 삭제 -> 마지막 노드를 루트노드로 이동 -> 자식노드(1~2개)들과 비교하며 가장 큰 값과 자리 변경